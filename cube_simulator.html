<!DOCTYPE html>
<html lang="zh-cn">

<head>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="./static/css/bootstrap.min.css">
  <link rel="icon" href="/MaplestoryWiki/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/MaplestoryWiki/favicon.ico" type="image/x-icon">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>魔方模拟器(施工中)</title>
  <style>
    /* 预留侧栏宽度后在剩余区域居中（通用） */
    .remain-center {
      padding-left: 240px;
    }

    .remain-center .inner {
      margin: 0 auto;
      width: min(1100px, calc(100vw - 240px));
      min-width: 320px;
      padding: 0 12px;
    }
  </style>
</head>

<body>
  <!-- JavaScript 动态加载左侧目录 -->
  <div id="sidebar-container"></div>
  <div class="container my-4">
    <div class="remain-center">
      <div class="inner">
        <h1 class="mb-4">魔方模拟器</h1>

        <div class="row g-4">
          <div class="col-12">
            <div class="card shadow-sm mb-4">
              <div class="card-header fw-bold" role="button" data-bs-toggle="collapse" data-bs-target="#cubeCollapse"
                aria-expanded="true" aria-controls="cubeCollapse">魔方概率查询</div>
              <div id="cubeCollapse" class="collapse show">
                <div class="card-body">
                  <div class="row g-3 align-items-end">
                    <div class="col-12 col-md-3">
                      <label class="form-label">装备类型</label>
                      <select id="equipType" class="form-select">
                        <option value="武器">武器</option>
                        <option value="辅助武器">辅助武器</option>
                        <option value="徽章">徽章</option>
                        <option value="坠饰">坠饰</option>
                        <option value="戒指">戒指</option>
                        <option value="脸部装饰">脸部装饰</option>
                        <option value="眼部装饰">眼部装饰</option>
                        <option value="耳环">耳环</option>
                        <option value="帽子">帽子</option>
                        <option value="上衣">上衣</option>
                        <option value="套服">套服</option>
                        <option value="下衣">下衣</option>
                        <option value="手套">手套</option>
                        <option value="鞋子">鞋子</option>
                        <option value="披风">披风</option>
                        <option value="腰带">腰带</option>
                        <option value="肩膀">肩膀</option>
                        <option value="心脏">心脏</option>
                        <option value="胸章">胸章</option>
                      </select>
                    </div>
                    <div class="col-6 col-md-3">
                      <label class="form-label">装备等级</label>
                      <select id="equipLevel" class="form-select">
                        <option value="140">140</option>
                        <option value="150" selected>150</option>
                        <option value="160">160</option>
                        <option value="200">200</option>
                        <option value="250">250</option>
                      </select>
                    </div>
                    <div class="col-12 col-md-3">
                      <label class="form-label">当前潜能</label>
                      <select id="currentTier" class="form-select">
                        <option value="Rare">特殊 (Rare)</option>
                        <option value="Epic">稀有 (Epic)</option>
                        <option value="Unique" selected>罕见 (Unique)</option>
                        <option value="Legendary">传说 (Legendary)</option>
                      </select>
                    </div>
                    <div class="col-12 col-md-3">
                      <label class="form-label">魔方类型</label>
                      <select id="cubeType" class="form-select">
                        <option>恢复方块</option>
                        <option>闪耀镜射方块</option>
                        <option>闪炫方块</option>
                        <option>新对等方块</option>
                        <option>结合方块</option>
                      </select>
                    </div>
                    <div class="col-12 d-flex gap-2 flex-wrap">
                      <button id="showBtn" class="btn btn-primary">准备打水漂</button>
                    </div>
                  </div>
                  <!-- 当前潜能选择框 -->
                  <div class="row g-3 mt-2" id="currentLinesGroup">
                    <div class="col-12 small text-muted">请选择当前三条潜能（默认均为“垃圾”）：</div>
                    <div class="col-12 col-md-4">
                      <label class="form-label">当前第1条</label>
                      <select id="currentLine1" class="form-select"></select>
                    </div>
                    <div class="col-12 col-md-4">
                      <label class="form-label">当前第2条</label>
                      <select id="currentLine2" class="form-select"></select>
                    </div>
                    <div class="col-12 col-md-4">
                      <label class="form-label">当前第3条</label>
                      <select id="currentLine3" class="form-select"></select>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="card shadow-sm mb-4">
          <div class="card-header fw-bold" role="button" data-bs-toggle="collapse" data-bs-target="#resultCollapse"
            aria-expanded="true" aria-controls="resultCollapse">跳框概率表</div>
          <div id="resultCollapse" class="collapse show">
            <div class="card-body">
              <div id="probSummary" class="mb-2 small text-muted"></div>
              <div class="table-responsive">
                <div id="probTableContainer" class="mt-2"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="card shadow-sm mb-4">
          <div class="card-header fw-bold" role="button" data-bs-toggle="collapse" data-bs-target="#tierResultCollapse"
            aria-expanded="true" aria-controls="tierResultCollapse">传说(Legendary)结果概率表</div>
          <div id="tierResultCollapse" class="collapse show">
            <div class="card-body">
              <div class="table-responsive">
                <div id="resultTierTableContainer" class="mt-2"></div>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script>

    // --- 固定顺序与显示名 ---
    const TIERS = ['Rare', 'Epic', 'Unique', 'Legendary'];
    const TIER_LABEL = {
      'Rare': '特殊 (Rare)',
      'Epic': '稀有 (Epic)',
      'Unique': '罕见 (Unique)',
      'Legendary': '传说 (Legendary)'
    };

    // --- 数据变量（从外部JSON加载） ---
    let cubeData = null;
    let uniqueData = null;
    let legendaryData = null;
    let dataLoaded = false;

    // --- 获取基础路径（适配GitHub Pages） ---
    function getBasePath() {
      const path = window.location.pathname;
      // 如果是 GitHub Pages (username.github.io/repo-name/)，提取仓库名
      const match = path.match(/^\/([^\/]+)\//);
      return match ? `/${match[1]}` : '';
    }

    // --- 加载所有JSON数据 ---
    async function loadData() {
      try {
        const basePath = getBasePath();
        const [cubeResponse, uniqueResponse, legendaryResponse] = await Promise.all([
          fetch(`${basePath}/data/cubeData.json`),
          fetch(`${basePath}/data/uniqueData.json`),
          fetch(`${basePath}/data/legendaryData.json`)
        ]);

        cubeData = await cubeResponse.json();
        uniqueData = await uniqueResponse.json();
        legendaryData = await legendaryResponse.json();
        
        dataLoaded = true;
        console.log('数据加载成功');
      } catch (error) {
        console.error('加载数据失败:', error);
        alert('加载数据失败，请刷新页面重试');
      }
    }

    // --- 辅助函数：确保返回包含所有等级键（缺的设为0） ---
    function normalizeToAllTiers(dist) {
      const out = {};
      for (const t of TIERS) out[t] = 0;
      for (const k in dist) {
        if (out.hasOwnProperty(k)) out[k] = Number(dist[k]) || 0;
      }
      return out;
    }

    // 计算给定装备类型与等级下的可选潜能（用于“当前潜能”三个下拉框）
    function buildLabeledNameGlobal(tier, name, equipLevel) {
      const isAllStat = name === '全属性%';
      const isMainStat = /^(STR%|DEX%|INT%|LUK%|最大HP%|物理攻击力%|魔法攻击力%|总伤害%)$/.test(name);
      const isHigh = Number(equipLevel) > 155;
      if (!isAllStat && !isMainStat) return name;
      let val;
      if (tier === 'Legendary') val = isAllStat ? (isHigh ? 10 : 9) : (isHigh ? 13 : 12);
      else val = isAllStat ? (isHigh ? 7 : 6) : (isHigh ? 10 : 9);
      const base = name.replace('%', '');
      return `${base}+${val}%`;
    }

    function pickPoolByType(source, cubeTypeKey, equipType) {
      if (!source || !source[cubeTypeKey]) return null;
      const dict = source[cubeTypeKey];
      if (dict[equipType]) return dict[equipType];
      return null;
    }

    function computeAvailableLines(equipType, equipLevel, currentTier) {
      if (!dataLoaded) return [];
      
      const poolLegend = pickPoolByType(legendaryData, '恢复方块', equipType) || {};
      const poolUnique = pickPoolByType(uniqueData, '恢复方块', equipType) || {};

      const options = [];
      // 垃圾固定项
      options.push({ value: 'TRASH', label: '垃圾' });

      function pushFromPool(tier, pool) {
        for (const k in pool) {
          if (k === '物理攻击力' || k === '魔法攻击力') continue; // 排除非百分比的固定数值行
          if (k === '垃圾') continue;
          // 合并“爆击几率%”为一个跨阶项
          const isCrit = k === '爆击几率%';
          const label = isCrit ? '爆击几率%' : buildLabeledNameGlobal(tier, k, equipLevel);
          const value = isCrit ? 'CRIT' : `${tier}::${k}`;
          options.push({ value, label });
        }
      }

      if (currentTier === 'Legendary') {
        // 传说可同时出现传说与罕见行
        pushFromPool('Legendary', poolLegend);
        pushFromPool('Unique', poolUnique);
      } else {
        // 非传说仅提供罕见词条
        pushFromPool('Unique', poolUnique);
      }

      // 去重并按标签排序（字典序）
      const seen = new Set();
      const dedup = [];
      for (const opt of options) {
        const key = opt.value;
        if (seen.has(key)) continue;
        seen.add(key);
        dedup.push(opt);
      }
      dedup.sort((a, b) => a.label.localeCompare(b.label, 'zh-Hans-CN'));
      // 确保“垃圾”在最前
      dedup.sort((a, b) => (a.value === 'TRASH' ? -1 : (b.value === 'TRASH' ? 1 : 0)));
      return dedup;
    }

    function fillCurrentLineSelects() {
      const equipType = document.getElementById('equipType').value;
      const equipLevel = document.getElementById('equipLevel').value;
      const currentTier = document.getElementById('currentTier').value;
      const opts = computeAvailableLines(equipType, equipLevel, currentTier);
      const ids = ['currentLine1', 'currentLine2', 'currentLine3'];
      ids.forEach(function (id) {
        const sel = document.getElementById(id);
        if (!sel) return;
        sel.innerHTML = '';
        opts.forEach(function (o) {
          const opt = document.createElement('option');
          opt.value = o.value;
          opt.textContent = o.label;
          sel.appendChild(opt);
        });
        sel.value = 'TRASH';
      });
    }

    function updateCurrentLinesUI() {
      const group = document.getElementById('currentLinesGroup');
      if (!group) return;
      const tier = document.getElementById('currentTier').value;
      const show = tier === 'Legendary';
      group.style.display = show ? '' : 'none';
      if (show) fillCurrentLineSelects();
    }

    // 计算「使用一次魔方后」的最终分布（最低从 Rare 开始）
    function getResultDistribution(cubeType, current) {
      if (!dataLoaded || !cubeData) return normalizeToAllTiers({});
      
      const data = cubeData[cubeType];
      if (!data) return normalizeToAllTiers({});
      const up = (data.upgrade && data.upgrade[current]) ? data.upgrade[current] : { [current]: 100.0 };
      return normalizeToAllTiers(up);
    }

    // 生成 HTML 表格并显示
    function renderProbabilityTable(cubeType, equipType, equipLevel, current) {
      const dist = getResultDistribution(cubeType, current);
      // 计算晋阶概率（比当前更高的等级）
      let promotionProb = 0;
      const currentIdx = TIERS.indexOf(current);
      for (let i = currentIdx + 1; i < TIERS.length; i++) {
        promotionProb += (dist[TIERS[i]] || 0);
      }

      // summary
      const summaryEl = document.getElementById('probSummary');
      let summaryHtml = `<strong>选择：</strong> 魔方：${cubeType}； 装备：${equipType}（Lv.${equipLevel}）； 当前潜能：${TIER_LABEL[current]}<br>`;
      summaryHtml += `<strong>晋阶概率（升到更高阶）：</strong> ${promotionProb.toFixed(2)}%`;
      summaryEl.innerHTML = summaryHtml;

      // table
      const container = document.getElementById('probTableContainer');
      let html = `<table class="table table-sm table-bordered" style="max-width:520px;"><thead><tr><th>潜能等级</th><th>概率</th></tr></thead><tbody>`;
      for (const t of TIERS) {
        html += `<tr><td>${TIER_LABEL[t]}</td><td style="min-width:140px">${(dist[t] || 0).toFixed(2)}%</td></tr>`;
      }
      html += `</tbody></table>`;

      container.innerHTML = html;
    }

    // 渲染“结果概率表”：根据不同的魔方类型调用对应处理函数
    function renderResultTierTable(cubeType, equipType, equipLevel, current) {
      const container = document.getElementById('resultTierTableContainer');
      if (!container) return;

      switch (cubeType) {
        case '恢复方块':
          return renderResultTableForRecovery(container, equipType, equipLevel, current);
        case '闪耀镜射方块':
          return renderResultTableForShiningMirror(container, equipType, equipLevel, current);
        case '闪炫方块':
          return renderResultTableForFlashing(container, equipType, equipLevel, current);
        case '新对等方块':
          return renderResultTableForNeoEqual(container, equipType, equipLevel, current);
        case '结合方块':
          return renderResultTableForFusion(container, equipType, equipLevel, current);
        default:
          return renderResultTableForRecovery(container, equipType, equipLevel, current);
      }
    }

    // 各魔方类型的结果概率表渲染函数
    function renderResultTableForRecovery(container, equipType, equipLevel, current) {
      if (!dataLoaded) {
        container.innerHTML = '<div class="alert alert-warning">数据加载中...</div>';
        return;
      }

      // 非传说：仅显示是否升级
      if (current !== 'Legendary') {
        const dist = getResultDistribution('恢复方块', current);
        const idx = TIERS.indexOf(current);
        let upgradeProb = 0;
        for (let i = idx + 1; i < TIERS.length; i++) upgradeProb += (dist[TIERS[i]] || 0);
        const stayProb = Math.max(0, 100 - upgradeProb);
        container.innerHTML = `
          <div class="small text-muted mb-2">恢复方块（当前非传说）仅判定是否升级：</div>
          <table class="table table-sm table-bordered mb-0" style="max-width:520px;">
            <thead><tr><th>结果</th><th style="width:140px">概率</th></tr></thead>
            <tbody>
              <tr><td>升级</td><td>${upgradeProb.toFixed(2)}%</td></tr>
              <tr><td>未升级</td><td>${stayProb.toFixed(2)}%</td></tr>
            </tbody>
          </table>`;
        return;
      }

      // 传说：三条潜能，每条先判定 Legendary/Unique，再按各自词条池抽取
      const data = cubeData['恢复方块'];
      const lowLevel = (data && data.lowLevel) ? data.lowLevel : {};
      const pUniqueLine = [0, Number(lowLevel['1']) || 0, Number(lowLevel['2']) || 0, Number(lowLevel['3']) || 0];
      const pLegendLine = [0, 100 - pUniqueLine[1], 100 - pUniqueLine[2], 100 - pUniqueLine[3]];

      // 装备类型别名处理
      const aliasList = (function () {
        const arr = [equipType];
        return Array.from(new Set(arr));
      })();

      function pickPool(source) {
        if (!source || !source['恢复方块']) return null;
        const dict = source['恢复方块'];
        for (const k of aliasList) if (dict[k]) return dict[k];
        return null;
      }

      const poolLegend = pickPool(legendaryData) || {};
      const poolUnique = pickPool(uniqueData) || {};

      // 过滤未知数值的“物理攻击力”“魔法攻击力”（不带百分号）
      function normalizeEntries(pool) {
        const out = [];
        for (const k in pool) {
          //if (k === '物理攻击力' || k === '魔法攻击力') continue;
          const v = Number(pool[k]) || 0;
          out.push({ name: k, p: v });
        }
        out.sort((a, b) => b.p - a.p);
        return out;
      }

      const entriesLegend = normalizeEntries(poolLegend);
      const entriesUnique = normalizeEntries(poolUnique);

      // 数值标注与合并表
      const isHigh = Number(equipLevel) > 155;
      function buildLabeledName(tier, name) {
        const isAllStat = name === '全属性%';
        const isMainStat = /^(STR%|DEX%|INT%|LUK%|最大HP%|物理攻击力%|魔法攻击力%|总伤害%)$/.test(name);
        if (!isAllStat && !isMainStat) return name;
        let val;
        if (tier === 'Legendary') val = isAllStat ? (isHigh ? 10 : 9) : (isHigh ? 13 : 12);
        else val = isAllStat ? (isHigh ? 7 : 6) : (isHigh ? 10 : 9);
        const base = name.replace('%', '');
        return `${base}+${val}%`;
      }

      const rowMap = new Map();
      function addRowsFromPool(tier, entries, lineProbs) {
        for (const row of entries) {
          const isTrash = row.name === '垃圾';
          const isCrit = row.name === '爆击几率%';
          const key = isTrash ? 'TRASH' : (isCrit ? 'CRIT' : (tier + '::' + row.name));
          const label = isTrash ? '垃圾' : (isCrit ? '爆击几率%' : buildLabeledName(tier, row.name));
          if (!rowMap.has(key)) rowMap.set(key, { label: label, probs: [0, 0, 0] });
          const rec = rowMap.get(key);
          rec.probs[0] += (row.p * lineProbs[1]) / 100;
          rec.probs[1] += (row.p * lineProbs[2]) / 100;
          rec.probs[2] += (row.p * lineProbs[3]) / 100;
        }
      }

      addRowsFromPool('Legendary', entriesLegend, pLegendLine);
      addRowsFromPool('Unique', entriesUnique, pUniqueLine);

      const allRows = Array.from(rowMap.values());

      const state = { key: 'sum', asc: false };
      const fmtProb = (v) => (v === 0 ? '/' : `${v.toFixed(2)}%`);

      function getSortedRows() {
        const rows = allRows.slice();
        rows.sort(function (a, b) {
          if (state.key === 'label') {
            return state.asc ? a.label.localeCompare(b.label) : b.label.localeCompare(a.label);
          }
          var vA = 0, vB = 0;
          if (state.key === 'c1') { vA = a.probs[0]; vB = b.probs[0]; }
          else if (state.key === 'c2') { vA = a.probs[1]; vB = b.probs[1]; }
          else if (state.key === 'c3') { vA = a.probs[2]; vB = b.probs[2]; }
          else { vA = a.probs[0] + a.probs[1] + a.probs[2]; vB = b.probs[0] + b.probs[1] + b.probs[2]; }
          return state.asc ? (vA - vB) : (vB - vA);
        });
        return rows;
      }

      function headerHtml(text, key, width) {
        const arrow = state.key === key ? (state.asc ? ' ▲' : ' ▼') : '';
        const w = width ? ` style=\"width:${width}\"` : '';
        return `<th role="button" data-key="${key}"${w}>${text}${arrow}</th>`;
      }

      function draw() {
        let html = `<div class="small text-muted">恢复方块：每次出现三条潜能；下表为一次使用下三条分别出现指定词条的概率。</div>`;
        html += `<div class="table-responsive"><table class="table table-sm table-striped table-hover align-middle mb-0">` +
          `<thead class="table-light"><tr>` +
          headerHtml('词条', 'label', '') +
          headerHtml('第一条', 'c1', '140px') +
          headerHtml('第二条', 'c2', '140px') +
          headerHtml('第三条', 'c3', '140px') +
          `</tr></thead><tbody>`;
        getSortedRows().forEach(function (r) {
          html += `<tr><td>${r.label}</td><td>${fmtProb(r.probs[0])}</td><td>${fmtProb(r.probs[1])}</td><td>${fmtProb(r.probs[2])}</td></tr>`;
        });
        html += `</tbody></table></div>`;
        container.innerHTML = html;

        // 绑定列头点击排序
        var ths = container.querySelectorAll('th[data-key]');
        ths.forEach(function (th) {
          th.style.cursor = 'pointer';
          th.addEventListener('click', function () {
            var key = th.getAttribute('data-key');
            if (state.key === key) {
              state.asc = !state.asc;
            } else {
              state.key = key;
              // 词条默认按字典序升序，其余列默认降序
              state.asc = (key === 'label');
            }
            draw();
          });
        });
      }

      draw();
    }

    // 通用渲染函数：用于3条潜能的方块
    function renderResultTableGeneric(container, cubeTypeName, equipType, equipLevel, current, numLines = 3) {
      if (!dataLoaded) {
        container.innerHTML = '<div class="alert alert-warning">数据加载中...</div>';
        return;
      }

      // 非传说：仅显示是否升级
      if (current !== 'Legendary') {
        const dist = getResultDistribution(cubeTypeName, current);
        const idx = TIERS.indexOf(current);
        let upgradeProb = 0;
        for (let i = idx + 1; i < TIERS.length; i++) upgradeProb += (dist[TIERS[i]] || 0);
        const stayProb = Math.max(0, 100 - upgradeProb);
        container.innerHTML = `
          <div class="small text-muted mb-2">${cubeTypeName}（当前非传说）仅判定是否升级：</div>
          <table class="table table-sm table-bordered mb-0" style="max-width:520px;">
            <thead><tr><th>结果</th><th style="width:140px">概率</th></tr></thead>
            <tbody>
              <tr><td>升级</td><td>${upgradeProb.toFixed(2)}%</td></tr>
              <tr><td>未升级</td><td>${stayProb.toFixed(2)}%</td></tr>
            </tbody>
          </table>`;
        return;
      }

      // 传说：每条潜能判定 Legendary/Unique，再按各自词条池抽取
      const data = cubeData[cubeTypeName];
      const lowLevel = (data && data.lowLevel) ? data.lowLevel : {};
      
      // 根据条数构建概率数组
      const pUniqueLine = [0];
      const pLegendLine = [0];
      for (let i = 1; i <= numLines; i++) {
        const uniqueP = Number(lowLevel[String(i)]) || 0;
        pUniqueLine.push(uniqueP);
        pLegendLine.push(100 - uniqueP);
      }

      function pickPool(source) {
        if (!source || !source[cubeTypeName]) return null;
        const dict = source[cubeTypeName];
        if (dict[equipType]) return dict[equipType];
        return null;
      }

      const poolLegend = pickPool(legendaryData) || {};
      const poolUnique = pickPool(uniqueData) || {};

      function normalizeEntries(pool) {
        const out = [];
        for (const k in pool) {
          const v = Number(pool[k]) || 0;
          out.push({ name: k, p: v });
        }
        out.sort((a, b) => b.p - a.p);
        return out;
      }

      const entriesLegend = normalizeEntries(poolLegend);
      const entriesUnique = normalizeEntries(poolUnique);

      const isHigh = Number(equipLevel) > 155;
      function buildLabeledName(tier, name) {
        const isAllStat = name === '全属性%';
        const isMainStat = /^(STR%|DEX%|INT%|LUK%|最大HP%|物理攻击力%|魔法攻击力%|总伤害%)$/.test(name);
        if (!isAllStat && !isMainStat) return name;
        let val;
        if (tier === 'Legendary') val = isAllStat ? (isHigh ? 10 : 9) : (isHigh ? 13 : 12);
        else val = isAllStat ? (isHigh ? 7 : 6) : (isHigh ? 10 : 9);
        const base = name.replace('%', '');
        return `${base}+${val}%`;
      }

      const rowMap = new Map();
      function addRowsFromPool(tier, entries, lineProbs) {
        for (const row of entries) {
          const isTrash = row.name === '垃圾';
          const isCrit = row.name === '爆击几率%';
          const key = isTrash ? 'TRASH' : (isCrit ? 'CRIT' : (tier + '::' + row.name));
          const label = isTrash ? '垃圾' : (isCrit ? '爆击几率%' : buildLabeledName(tier, row.name));
          
          if (!rowMap.has(key)) {
            const probs = new Array(numLines).fill(0);
            rowMap.set(key, { label: label, probs: probs });
          }
          const rec = rowMap.get(key);
          for (let i = 0; i < numLines; i++) {
            rec.probs[i] += (row.p * lineProbs[i + 1]) / 100;
          }
        }
      }

      addRowsFromPool('Legendary', entriesLegend, pLegendLine);
      addRowsFromPool('Unique', entriesUnique, pUniqueLine);

      const allRows = Array.from(rowMap.values());

      const state = { key: 'sum', asc: false };
      const fmtProb = (v) => (v === 0 ? '/' : `${v.toFixed(2)}%`);

      function getSortedRows() {
        const rows = allRows.slice();
        rows.sort(function (a, b) {
          if (state.key === 'label') {
            return state.asc ? a.label.localeCompare(b.label) : b.label.localeCompare(a.label);
          }
          let vA = 0, vB = 0;
          if (state.key.startsWith('c')) {
            const idx = parseInt(state.key.substring(1)) - 1;
            vA = a.probs[idx] || 0;
            vB = b.probs[idx] || 0;
          } else {
            vA = a.probs.reduce((sum, p) => sum + p, 0);
            vB = b.probs.reduce((sum, p) => sum + p, 0);
          }
          return state.asc ? (vA - vB) : (vB - vA);
        });
        return rows;
      }

      function headerHtml(text, key, width) {
        const arrow = state.key === key ? (state.asc ? ' ▲' : ' ▼') : '';
        const w = width ? ` style=\"width:${width}\"` : '';
        return `<th role="button" data-key="${key}"${w}>${text}${arrow}</th>`;
      }

      function draw() {
        let html = `<div class="small text-muted">${cubeTypeName}：每次出现${numLines}条潜能；下表为一次使用下${numLines}条分别出现指定词条的概率。</div>`;
        html += `<div class="table-responsive"><table class="table table-sm table-striped table-hover align-middle mb-0">` +
          `<thead class="table-light"><tr>` +
          headerHtml('词条', 'label', '');
        
        for (let i = 1; i <= numLines; i++) {
          html += headerHtml(`第${i}条`, `c${i}`, '140px');
        }
        
        html += `</tr></thead><tbody>`;
        getSortedRows().forEach(function (r) {
          html += `<tr><td>${r.label}</td>`;
          for (let i = 0; i < numLines; i++) {
            html += `<td>${fmtProb(r.probs[i])}</td>`;
          }
          html += `</tr>`;
        });
        html += `</tbody></table></div>`;
        container.innerHTML = html;

        // 绑定列头点击排序
        const ths = container.querySelectorAll('th[data-key]');
        ths.forEach(function (th) {
          th.style.cursor = 'pointer';
          th.addEventListener('click', function () {
            const key = th.getAttribute('data-key');
            if (state.key === key) {
              state.asc = !state.asc;
            } else {
              state.key = key;
              state.asc = (key === 'label');
            }
            draw();
          });
        });
      }

      draw();
    }

    function renderResultTableForShiningMirror(container, equipType, equipLevel, current) {
      renderResultTableGeneric(container, '闪耀镜射方块', equipType, equipLevel, current, 3);
    }

    function renderResultTableForFlashing(container, equipType, equipLevel, current) {
      renderResultTableGeneric(container, '闪炫方块', equipType, equipLevel, current, 6);
    }

    function renderResultTableForNeoEqual(container, equipType, equipLevel, current) {
      renderResultTableGeneric(container, '新对等方块', equipType, equipLevel, current, 3);
    }

    function renderResultTableForFusion(container, equipType, equipLevel, current) {
      renderResultTableGeneric(container, '结合方块', equipType, equipLevel, current, 3);
    }

    // --- 事件绑定（仅在点击按钮时更新） ---
    const inputs = ['equipType', 'equipLevel', 'currentTier', 'cubeType', 'showBtn'];
    async function setup() {
      // 先加载数据
      await loadData();
      
      document.getElementById('showBtn').addEventListener('click', () => {
        if (!dataLoaded) {
          alert('数据尚未加载完成，请稍候');
          return;
        }
        const equipType = document.getElementById('equipType').value;
        const equipLevel = document.getElementById('equipLevel').value;
        const current = document.getElementById('currentTier').value;
        const cubeType = document.getElementById('cubeType').value;
        renderProbabilityTable(cubeType, equipType, equipLevel, current);
        renderResultTierTable(cubeType, equipType, equipLevel, current);
      });
      // 条件变化时刷新"当前潜能"可选项
      ['equipType', 'equipLevel', 'currentTier'].forEach(function (id) {
        const el = document.getElementById(id);
        el.addEventListener('change', updateCurrentLinesUI);
      });
      // 初始显示与填充（仅当Legendary时填充）
      updateCurrentLinesUI();
    }
    // 加载侧边栏
    const basePath = getBasePath();
    fetch(`${basePath}/sidebar.html`)
      .then(response => response.text())
      .then(data => {
        document.getElementById('sidebar-container').innerHTML = data;
      })
      .catch(error => {
        console.error('加载侧边栏失败:', error);
      });

    function toggleSubMenu(id) {
      const submenu = document.getElementById(id);
      submenu.style.display = submenu.style.display === "block" ? "none" : "block";
    }
    // 绑定事件与首次渲染
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', setup);
    } else {
      setup();
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>